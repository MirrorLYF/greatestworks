

Redis实现排行榜及相同积分按时间排序

不考虑积分相同
Redis的Sorted Set是String类型的有序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。

每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

有序集合的成员是唯一的，但分数(score)却可以重复。

积分相同按时间排序，排名唯一
在上面的实现中，如果两个队伍的贡献值相同，也就是积分值相同，无法根据时间的先后进行排行。

所以需要设计一个分数 = 贡献值 + 时间戳 ，谁分数大谁排前面，最后还要能根据分数能解析出来贡献值。


设计1
使用整型存储分数值，redis中score本身是一个double类型，能精确存储的最大整型数字为2^53=9007199254740992（16位）。而精确到毫秒的时间戳需要13位，此时留给存储贡献值只有3位数了，当前如果时间只要精确到秒，只需要10位，这样留给贡献值就有6位。

整体设计：高3位表示贡献值，低13位表示时间戳。

如果我们简单地把score结构由：贡献值 * 10^13 + 时间戳 拼凑，因为分数越大越靠前，而时间戳越小则越靠前，这样两部分的判断规则是相反的，无法简单把两者合成一起成为score。

但是我们可以逆向思维，可以用同一个足够大的数Integer.MAX减去时间戳，时间戳越小，则得到的差值越大，这样我们就可以把score的结构改为：贡献值 * 10^13 + (Integer.MAX-时间戳)，这样就能满足我们的需求了。

设计2
由于redis的score值是double类型，可以使用整数部分存储贡献值，小数部分存储时间戳，同样时间戳的部分使用一个最大值减去它。

这样，整体设计变为：分数=贡献值 + (Integer.MAX-时间戳) * 10^-13

弊端：由于分数值是由两个变量来计算得出，所以在给队伍增加贡献值时，无法简单的使用之前的zincrby来改变score的值了，这样在并发情况下为队伍增加贡献值就会导致score值不准确。

错误情况模拟：

假设现在队伍A的贡献值为10
队伍A中的队员X为队伍增加贡献值1，在程序中算出score为11.xxx
队伍A中的队员Y为队伍增加贡献值1，在程序中算出score为11.yyy
队伍A中的队员X调用redis的zadd命令设置队伍的贡献值为11.xxx
队伍A中的队员Y调用redis的zadd命令设置队伍的贡献值为11.yyy
最后算出队伍A的贡献值为11，无法保证增加贡献值这一个操作的原子性。
此时需要借助lua脚本来保证计算和设置贡献值这两个操作的原子性：

// 其中KEYS[1]为排行榜key，KEYS[2]为队伍ID
// 其中ARGV[1]为增加的贡献值，ARGV[2]为Integer.MAX-时间戳
local score = redis.call('zscore', KEYS[1], KEYS[2])
if not(score) then
	score=0
end
score=math.floor(score) + tonumber(ARGV[1]) + tonumber(ARGV[2])
redis.call('zadd', KEYS[1], score, KEYS[2]) return 1

由于redis中无法使用时间函数，所以(Integer.MAX-时间戳) * 10^-13部分由脚本外程序计算好传入。

分页查询排行榜，查询队伍的排名等功能都可以继续使用上面的命令。

